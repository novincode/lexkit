#!/usr/bin/env tsx

import fs from 'fs'
import path from 'path'
import { codeToHtml } from 'shiki'

interface GeneratedRegistry {
  files: Record<string, { raw: string; highlighted: string }>
  lastGenerated: string
}

/**
 * Build-time code registry generator
 * This script scans all example files and generates a static registry
 * that can be imported directly without runtime processing
 */
class CodeRegistryGenerator {
  private examplesDir: string
  private outputDir: string

  constructor() {
    this.examplesDir = path.resolve(process.cwd(), 'app/docs/(docs)/introduction/examples')
    this.outputDir = path.resolve(process.cwd(), 'lib/generated')
  }

  /**
   * Ensure output directory exists
   */
  private ensureOutputDir(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true })
    }
  }

  /**
   * Scan and discover all code files
   */
  private discoverFiles(): string[] {
    const files = fs.readdirSync(this.examplesDir)
    return files.filter(file => {
      const ext = path.extname(file)
      return ext === '.tsx' || ext === '.css'
    })
  }

  /**
   * Process code file with Shiki
   */
  private async processCodeFile(filePath: string, language: string): Promise<string> {
    const fullPath = path.resolve(this.examplesDir, filePath)
    const content = fs.readFileSync(fullPath, 'utf-8')

    return await codeToHtml(content, {
      lang: language,
      theme: 'github-dark'
    })
  }

  /**
   * Generate the static registry
   */
  async generateRegistry(): Promise<void> {
    console.log('üîç Scanning code files...')

    const files = this.discoverFiles()
    console.log(`üìÅ Found ${files.length} files:`, files)

    const registry: GeneratedRegistry = {
      files: {},
      lastGenerated: new Date().toISOString()
    }

    // Process each file
    for (const file of files) {
      console.log(`‚öôÔ∏è  Processing ${file}...`)

      const ext = path.extname(file)
      const language = ext === '.tsx' ? 'tsx' : 'css'

      const fullPath = path.resolve(this.examplesDir, file)
      const rawContent = fs.readFileSync(fullPath, 'utf-8')
      const highlighted = await this.processCodeFile(file, language)
      
      registry.files[file] = {
        raw: rawContent,
        highlighted: highlighted
      }
    }

    // Generate TypeScript file
    this.ensureOutputDir()
    const outputPath = path.join(this.outputDir, 'code-registry.ts')

    const tsContent = `// Auto-generated code registry - DO NOT EDIT MANUALLY
// Generated on: ${registry.lastGenerated}
// This file is generated by scripts/generate-registry.ts

export interface CodeFile {
  raw: string
  highlighted: string
}

export interface CodeRegistry {
  files: Record<string, CodeFile>
  lastGenerated: string
}

const registry: CodeRegistry = ${JSON.stringify(registry, null, 2)}

export default registry

// Helper functions
export function getCode(filePath: string): CodeFile | undefined {
  return registry.files[filePath]
}

export function getHighlightedCode(filePath: string): string | undefined {
  return registry.files[filePath]?.highlighted
}

export function getRawCode(filePath: string): string | undefined {
  return registry.files[filePath]?.raw
}

export function getAllFiles(): string[] {
  return Object.keys(registry.files)
}
`

    fs.writeFileSync(outputPath, tsContent)
    console.log(`‚úÖ Registry generated successfully at: ${outputPath}`)
    console.log(`üìä Generated ${Object.keys(registry.files).length} files`)
  }
}

// Run the generator
async function main() {
  try {
    console.log('üöÄ Starting code registry generation...')
    const generator = new CodeRegistryGenerator()
    await generator.generateRegistry()
    console.log('‚úÖ Code registry generation completed!')
  } catch (error) {
    console.error('‚ùå Registry generation failed:', error)
    process.exit(1)
  }
}

main()
